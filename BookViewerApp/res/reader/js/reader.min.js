(() => { "use strict"; const e = "is not an instance of UIElement."; class t { constructor(e) { this.dom = e } add() { for (let s = 0; s < arguments.length; s++) { const i = arguments[s]; if (i instanceof t) this.dom.appendChild(i.dom); else if (Array.isArray(i)) for (let s = 0; s < i.length; s++) { const n = i[s]; n instanceof t ? this.dom.appendChild(n.dom) : console.error("UIElement:", n, e) } else console.error("UIElement:", i, e) } return this } remove() { for (let s = 0; s < arguments.length; s++) { const i = arguments[s]; i instanceof t ? this.dom.removeChild(i.dom) : console.error("UIElement:", i, e) } return this } clear() { for (; this.dom.children.length;)this.dom.removeChild(this.dom.lastChild) } setId(e) { return this.dom.id = e, this } getId() { return this.dom.id } setClass(e) { return this.dom.className = e, this } addClass(e) { return this.dom.classList.add(e), this } removeClass(e) { return this.dom.classList.remove(e), this } setStyle(e, t) { for (let s = 0; s < t.length; s++)this.dom.style[e] = t[s]; return this } setDisabled(e) { return this.dom.disabled = e, this } setTextContent(e) { return this.dom.textContent = e, this } getRect() { return this.dom.getBoundingClientRect(), this } } ["position", "left", "top", "right", "bottom", "width", "height", "border", "borderLeft", "borderTop", "borderRight", "borderBottom", "borderColor", "display", "overflow", "margin", "marginLeft", "marginTop", "marginRight", "marginBottom", "padding", "paddingLeft", "paddingTop", "paddingRight", "paddingBottom", "color", "background", "backgroundColor", "opacity", "fontSize", "fontWeight", "textAlign", "textDecoration", "textTransform", "cursor", "zIndex"].forEach((function (e) { const s = "set" + e.substr(0, 1).toUpperCase() + e.substr(1, e.length); t.prototype[s] = function () { return this.setStyle(e, arguments), this } })), ["KeyUp", "KeyDown", "MouseOver", "MouseOut", "Click", "DblClick", "Change", "Input"].forEach((function (e) { const s = "on" + e; t.prototype[s] = function (t) { return this.dom.addEventListener(e.toLowerCase(), t.bind(this), !1), this } })); class s extends t { constructor() { super(document.createElement("span")) } } class i extends t { constructor() { super(document.createElement("div")) } } class n extends i { constructor() { super(), this.dom.className = "row" } } class o extends i { constructor() { super(), this.dom.className = "panel" } } class a extends t { constructor(e, t) { super(document.createElement("label")), this.dom.textContent = e, t && (this.dom.htmlFor = t) } } class r extends s { constructor(e) { super(), this.setValue(e) } getValue() { return this.dom.textContent } setValue(e) { return void 0 !== e && (this.dom.textContent = e), this } } class d extends t { constructor(e, t, s) { super(document.createElement("input")), this.dom.type = e, this.dom.addEventListener("keydown", (function (e) { e.stopPropagation() }), !1), this.setValue(t), this.setTitle(s) } getName() { return this.dom.name } setName(e) { return this.dom.name = e, this } getType() { return this.dom.type } setType(e) { return this.dom.type = e, this } getValue() { return this.dom.value } setValue(e) { return void 0 !== e && (this.dom.value = e), this } getTitle() { return this.dom.title } setTitle(e) { return void 0 !== e && (this.dom.title = e), this } readonly(e) { return this.dom.readOnly = e, this } } class l extends t { constructor() { super(document.createElement("textarea")), this.dom.spellcheck = !1, this.dom.addEventListener("keydown", (function (e) { if (e.stopPropagation(), 9 === e.keyCode) { e.preventDefault(); const t = dom.selectionStart; this.dom.value = this.dom.value.substring(0, t) + "\t" + this.dom.value.substring(t), this.dom.selectionStart = t + 1, this.dom.selectionEnd = this.dom.selectionStart } }), !1) } getValue() { return this.dom.value } setValue(e) { return this.dom.value = e, this } } class h extends t { constructor() { super(document.createElement("select")) } setMultiple(e) { return this.dom.multiple = e || !1, this } setOptions(e) { const t = this.dom.value; for (; this.dom.children.length > 0;)this.dom.removeChild(this.dom.firstChild); for (const t in e) { const s = document.createElement("option"); s.value = t, s.innerHTML = e[t], this.dom.appendChild(s) } return this.dom.value = t, this } getValue() { return this.dom.value } setValue(e) { return e = String(e), this.dom.value !== e && (this.dom.value = e), this } } class c extends i { constructor(e) { super(), this.tabs = [], this.panels = [], this.selector = (new s).setClass("tab-selector"), this.tabsDiv = new i, this.tabsDiv.dom.className = "tabs", this.tabsDiv.add(this.selector), this.panelsDiv = new i, this.panelsDiv.dom.className = "panels", this.add(this.tabsDiv), this.add(this.panelsDiv), this.align = e || "horizontal", this.selected = "" } select(e) { let t, s; if (this.selected && this.selected.length && (t = this.tabs.find((e => e.dom.id === this.selected)), s = this.panels.find((e => e.dom.id === this.selected)), t && t.removeClass("selected"), s && s.setDisplay("none")), t = this.tabs.find((function (t) { return t.dom.id === e })), s = this.panels.find((function (t) { return t.dom.id === e })), t) { let e; t.addClass("selected"); const s = t.dom.getBoundingClientRect(); "horizontal" === this.align ? (e = s.width * this.tabs.indexOf(t), this.selector.dom.style.transform = `translateX(${e}px)`) : (e = s.height * this.tabs.indexOf(t), this.selector.dom.style.transform = `translateY(${e}px)`) } return s && s.setDisplay(""), this.selected = e, this } addTab(e, t, s) { const n = new m(t, this); n.setId(e), n.setClass("tab"), this.tabs.push(n), this.tabsDiv.add(n); const o = new i; o.setId(e), o.add(s), o.setDisplay("none"), this.panels.push(o), this.panelsDiv.add(o), this.select(e) } } class m extends i { constructor(e, t) { super(e), this.button = new d("button"), this.button.dom.title = e, this.parent = t, this.dom.addEventListener("click", (() => { this.parent.select(this.dom.id) })), this.add(this.button) } } class u { constructor(e) { const t = e.signals; this.panel = (new o).setId("metadata"), this.title = (new r).setId("book-title"), this.creator = (new r).setId("book-creator"), this.separator = (new r).setId("book-title-separator"), this.panel.add([this.title, this.separator, this.creator]), t.metadata.add((e => { this.init(e) })) } init(e) { document.title = e.title + " â€“ " + e.creator, this.title.setValue(e.title), this.creator.setValue(e.creator), this.separator.dom.style.display = "inline-block" } } class g { constructor(e) { const t = e.signals, s = e.strings; this.sidebarOpen = !1; const n = (new i).setId("toolbar"), a = (new o).setId("start"), r = new d("button").setId("btn-s"), l = s.get("toolbar/opener"); r.dom.title = l, r.dom.addEventListener("click", (() => { this.sidebarOpen = !this.sidebarOpen, t.sidebarOpener.dispatch(this.sidebarOpen), this.sidebarOpen ? r.addClass("open") : r.removeClass("open") })), a.add(r); const h = new u(e), c = (new o).setId("end"), m = new d("file").setId("btn-u"), g = s.get("toolbar/upload"), b = window.storage; m.dom.title = g, m.dom.accept = "application/epub+zip", m.dom.addEventListener("change", (function (t) { if (0 !== t.target.files.length) if (window.FileReader) { const s = new FileReader; s.onload = function (t) { b.clear(), b.set(t.target.result, (() => { e.unload(), e.content.viewer.clear(), e.init(t.target.result, { restore: !0 }) })) }, s.readAsArrayBuffer(t.target.files[0]), s.onerror = function (e) { console.error(e) }, window.location.href.includes("?bookPath=") && (window.location.href = window.location.origin + window.location.pathname) } else alert(s.get("toolbar/upload/error")) }), !1), c.add(m); const p = new d("button").setId("btn-b"), k = s.get("toolbar/bookmark"); if (p.dom.title = k, p.dom.addEventListener("click", (() => { const s = e.rendition.currentLocation().start.cfi; t.bookmarked.dispatch(-1 === e.isBookmarked(s)) })), c.add(p), document.fullscreenEnabled) { const e = new d("button").setId("btn-f"), t = s.get("toolbar/fullsceen"); e.dom.title = t, e.dom.addEventListener("click", (() => { this.toggleFullScreen() })), document.addEventListener("keydown", (e => { "F11" === e.key && (e.preventDefault(), this.toggleFullScreen()) }), !1), document.addEventListener("fullscreenchange", (t => { const s = window.screen.width === t.path[2].innerWidth, i = window.screen.height === t.path[2].innerHeight; s && i ? e.addClass("resize-small") : e.removeClass("resize-small") }), !1), c.add(e) } n.add([a, h.panel, c]), document.body.appendChild(n.dom), t.relocated.add((t => { const s = t.start.cfi; -1 === e.isBookmarked(s) ? p.removeClass("bookmarked") : p.addClass("bookmarked") })), t.bookmarked.add((e => { e ? p.addClass("bookmarked") : p.removeClass("bookmarked") })) } toggleFullScreen() { document.activeElement.blur(), null === document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen && document.exitFullscreen() } } class b { constructor(e) { const t = e.signals; this.panel = (new o).setId("contents"), this.reader = e, t.navigation.add((e => { this.init(e) })) } init(e) { this.panel.clear(), this.panel.dom.appendChild(this.generateToc(e)) } generateToc(e, t) { const s = document.createElement("ul"); return t || (t = 1), e.forEach((e => { const i = document.createElement("li"), n = document.createElement("a"), o = document.createElement("div"); if (o.id = "expander", i.id = e.id, n.href = e.href, n.textContent = e.label, n.onclick = () => (this.reader.rendition.display(e.href), !1), i.appendChild(o), i.appendChild(n), e.subitems && e.subitems.length > 0) { t++; const s = this.generateToc(e.subitems, t), a = document.createElement("span"); a.className = "toggle-collapsed", a.onclick = () => ("toggle-collapsed" === a.className ? (a.className = "toggle-expanded", s.style.display = "block") : (a.className = "toggle-collapsed", s.style.display = "none"), !1), o.appendChild(a), i.insertBefore(o, n), i.appendChild(s) } s.appendChild(i) })), s } } class p { constructor(e) { const t = e.signals, s = e.strings, i = new n, a = [s.get("sidebar/bookmarks/add"), s.get("sidebar/bookmarks/remove"), s.get("sidebar/bookmarks/clear")], r = new d("button", a[0]).addClass("btn-start"), l = new d("button", a[1]).addClass("btn-medium"), h = new d("button", a[2]).addClass("btn-end"); r.dom.onclick = () => (t.bookmarked.dispatch(!0), !1), l.dom.onclick = () => (t.bookmarked.dispatch(!1), !1), h.dom.onclick = () => (this.clearBookmarks(), t.bookmarked.dispatch(!1), !1), i.add([r, l, h]), this.reader = e, this.panel = (new o).setId("bookmarks"), this.bookmarks = document.createElement("ul"), this.panel.add(i), this.panel.dom.appendChild(this.bookmarks); const c = () => { l.dom.disabled = 0 === e.settings.bookmarks.length, h.dom.disabled = 0 === e.settings.bookmarks.length }; t.bookready.add((() => { e.settings.bookmarks.forEach((e => { const t = this.createBookmarkItem(e); this.bookmarks.appendChild(t) })), c() })), t.relocated.add((t => { const s = t.start.cfi, i = -1 === e.isBookmarked(s); r.dom.disabled = !i, l.dom.disabled = i })), t.bookmarked.add((t => { const s = e.rendition.currentLocation().start.cfi; t ? (this.addBookmark(s), r.dom.disabled = !0) : (this.removeBookmark(s), r.dom.disabled = !1), c() })) } addBookmark(e) { if (this.reader.isBookmarked(e) > -1) return; const t = this.createBookmarkItem(e); this.bookmarks.appendChild(t), this.reader.settings.bookmarks.push(e) } removeBookmark(e) { const t = this.reader.isBookmarked(e); -1 !== t && (this.bookmarks.removeChild(this.bookmarks.childNodes[t]), this.reader.settings.bookmarks.splice(t, 1)) } clearBookmarks() { for (this.reader.settings.bookmarks = []; this.bookmarks.hasChildNodes();)this.bookmarks.removeChild(this.bookmarks.lastChild) } createBookmarkItem(e) { const t = document.createElement("li"), s = document.createElement("a"), i = this.reader.book, n = i.spine.get(e); if (n.index in i.navigation.toc) { const e = i.navigation.toc[n.index]; t.id = e.id, s.textContent = e.label } else s.textContent = e; return s.href = "#" + e, s.onclick = () => (this.reader.rendition.display(e), !1), t.appendChild(s), t } } class k { constructor(e) { const t = e.signals, s = e.strings; this.panel = (new o).setId("annotations"), this.notes = document.createElement("ul"); const i = new l; i.dom.addEventListener("input", (e => { u() && e.target.value.length > 0 ? c.dom.disabled = !1 : c.dom.disabled = !0 })), this.reader = e, this.range, this.cfiRange; const a = [s.get("sidebar/annotations/add"), s.get("sidebar/annotations/clear")], r = new n, h = new n, c = new d("button", a[0]).addClass("btn-start"); c.dom.disabled = !0, c.dom.onclick = () => { const t = { date: new Date, text: i.getValue(), href: this.cfiRange, uuid: e.uuid() }; return e.settings.annotations.push(t), this.add(t), i.setValue(""), c.dom.disabled = !0, !1 }; const m = new d("button", a[1]).addClass("btn-end"); m.dom.disabled = !0, m.dom.onclick = () => (this.clearNotes(), !1), r.add(i), h.add([c, m]), this.panel.add([r, h]), this.panel.dom.appendChild(this.notes), this.update = () => { m.dom.disabled = 0 === e.settings.annotations.length }; const u = () => this.range && this.range.startOffset !== this.range.endOffset; t.bookready.add((() => { e.settings.annotations.forEach((e => { this.add(e) })) })), t.selected.add(((e, t) => { this.range = t.range(e), this.cfiRange = e, u() && i.getValue().length > 0 ? c.dom.disabled = !1 : c.dom.disabled = !0 })), t.unselected.add((() => { c.dom.disabled = !0 })) } add(e) { const t = document.createElement("li"), s = document.createElement("a"), i = document.createElement("span"); s.href = "#" + e.href, s.textContent = e.text, s.onclick = () => (this.reader.rendition.display(e.href), !1), t.id = "note-" + e.uuid, t.appendChild(s), i.className = "btn-remove", i.onclick = () => (this.remove(e), !1), t.appendChild(i), this.notes.appendChild(t), this.reader.rendition.annotations.add("highlight", e.href, {}, (() => { }), "note-highlight", {}), this.update() } remove(e) { const t = this.reader.settings.annotations.indexOf(e); -1 !== t && (this.notes.removeChild(this.notes.childNodes[t]), this.reader.settings.annotations.splice(t, 1), this.reader.rendition.annotations.remove(e.href, "highlight"), this.update()) } clearNotes() { const e = this.reader.settings.annotations.length; for (let t = 0; t < e; t++)this.remove(this.reader.settings.annotations[t]) } } class v { constructor(e) { const t = e.strings; this.panel = (new o).setId("search"), this.query = void 0, this.pages = [], this.searchBox = new d("search"), this.searchBox.dom.placeholder = t.get("sidebar/search/placeholder"), this.searchBox.dom.addEventListener("search", (() => { const e = this.searchBox.getValue(); 0 === e.length ? (this.clear(), this.query = e) : this.query !== e && (this.clear(), this.query = e, this.doSearch(e).then((e => { e.forEach((e => { this.set(e) })) }))) })), this.searchResult = document.createElement("ul"); const s = new n; s.add(this.searchBox), this.panel.add(s), this.panel.dom.appendChild(this.searchResult), this.reader = e } async doSearch(e) { const t = this.reader.book, s = await Promise.all(t.spine.spineItems.map((s => s.load(t.load.bind(t)).then(s.find.bind(s, e)).finally(s.unload.bind(s))))); return await Promise.resolve([].concat.apply([], s)) } set(e) { const t = document.createElement("li"), s = document.createElement("a"); s.href = "#" + e.cfi, s.textContent = e.excerpt, s.onclick = () => (this.reader.rendition.display(e.cfi), !1), t.appendChild(s), this.searchResult.appendChild(t) } clear() { for (; this.searchResult.hasChildNodes();)this.searchResult.removeChild(this.searchResult.lastChild) } } class f { constructor(e) { const t = e.signals, s = e.strings; this.panel = (new o).setId("settings"); const i = s.get("sidebar/settings/language"), r = new n, l = (new h).setOptions({ en: "English", fr: "French" }); l.dom.addEventListener("change", (t => { e.settings.language = t.target.value })), r.add(new a(i)), r.add(l); const c = s.get("sidabar/settings/reflowtext"), m = new n, u = new d("checkbox", !1, c[1]); u.setId("reflowtext"), u.dom.addEventListener("click", (t => { e.settings.reflowText = t.target.checked, e.rendition.resize() })), m.add(new a(c[0], "reflowtext")), m.add(u); const g = s.get("sidebar/settings/pagination"), b = new n, p = new d("checkbox", !1, g[1]); p.setId("pagination"), p.dom.addEventListener("click", (t => { e.settings.pagination = t.target.checked, e.generatePagination() })), b.add(new a(g[0], "pagination")), b.add(p), this.panel.add([r]), t.bookready.add((() => { l.setValue(e.settings.language) })) } } class w { constructor(e) { const t = e.strings, s = [t.get("sidebar/contents"), t.get("sidebar/bookmarks"), t.get("sidebar/annotations"), t.get("sidebar/search"), t.get("sidebar/settings")]; this.toc = new b(e), this.bookmarks = new p(e), this.annotations = new k(e), this.search = new v(e), this.settings = new f(e), this.container = new c("vertical").setId("sidebar"), this.container.addTab("tab-t", s[0], this.toc.panel), this.container.addTab("tab-b", s[1], this.bookmarks.panel), this.container.addTab("tab-n", s[2], this.annotations.panel), this.container.addTab("tab-s", s[3], this.search.panel), this.container.addTab("tab-c", s[4], this.settings.panel), this.container.select("tab-t"), document.body.appendChild(this.container.dom) } } class y { constructor(e) { const t = e.signals; this.main = (new i).setId("content"), this.main.dom.addEventListener("transitionend", (t => { e.settings.sidebarReflow && e.rendition.resize() })), this.prev = (new i).setId("prev").setClass("arrow"), this.prev.dom.addEventListener("click", (t => { "rtl" === e.book.package.metadata.direction ? e.rendition.next() : e.rendition.prev(), t.preventDefault() })), this.prev.add(new a("<")), this.next = (new i).setId("next").setClass("arrow"), this.next.dom.addEventListener("click", (t => { "rtl" === e.book.package.metadata.direction ? e.rendition.prev() : e.rendition.next(), t.preventDefault() })), this.next.add(new a(">")), this.viewer = (new i).setId("viewer"), this.divider = (new i).setId("divider"), this.loader = (new i).setId("loader"), this.main.add([this.prev, this.viewer, this.next, this.divider, this.loader]), this.reader = e, document.body.appendChild(this.main.dom), t.sidebarOpener.add((e => { e ? this.slideOut() : this.slideIn() })), t.layout.add((e => { !0 === e.spread && e.width > e.spreadWidth ? this.showDivider() : this.hideDivider() })), t.relocated.add((e => { e.atStart ? this.prev.addClass("disabled") : this.prev.removeClass("disabled"), e.atEnd ? this.next.addClass("disabled") : this.next.removeClass("disabled") })) } slideIn() { this.reader.settings.sidebarReflow, this.main.removeClass("single"), this.main.removeClass("closed") } slideOut() { this.reader.settings.sidebarReflow ? this.main.addClass("single") : this.main.addClass("closed") } showLoader() { this.loader.dom.style.display = "block", this.hideDivider() } hideLoader() { this.loader.dom.style.display = "none", this.reader.book.settings.spreads && this.showDivider() } showDivider() { this.divider.dom.style.display = "block" } hideDivider() { this.divider.dom.style.display = "none" } } class x { constructor(e) { this.language = e.settings.language || "en", this.values = { en: { "toolbar/opener": "Sidebar", "toolbar/upload": "Upload book", "toolbar/upload/error": "Your browser does not support the required features.\nPlease use a modern browser such as Google Chrome, or Mozilla Firefox.", "toolbar/bookmark": "Add this page to bookmarks", "toolbar/fullsceen": "Fullscreen", "sidebar/contents": "Contents", "sidebar/bookmarks": "Bookmarks", "sidebar/bookmarks/add": "Add", "sidebar/bookmarks/remove": "Remove", "sidebar/bookmarks/clear": "Clear", "sidebar/annotations": "Annotations", "sidebar/annotations/add": "Add", "sidebar/annotations/clear": "Clear", "sidebar/annotations/anchor": "Anchor", "sidebar/annotations/cancel": "Cancel", "sidebar/search": "Search", "sidebar/search/placeholder": "search", "sidebar/settings": "Settings", "sidebar/settings/language": "Language", "sidabar/settings/reflowtext": ["Reflow text", "Reflow text when sidebars are open"], "sidebar/settings/pagination": ["Pagination", "Generate pagination"] }, fr: { "toolbar/opener": "Barre latÃ©rale", "toolbar/upload": "Ouvrir un livre local", "toolbar/upload/error": "Votre navigateur ne prend pas en charge les fonctions nÃ©cessaires.\nVeuillez utiliser un navigateur moderne tel que Google Chrome ou Mozilla Firefox.", "toolbar/bookmark": "InsÃ©rer un marque page ici", "toolbar/fullsceen": "Plein Ã©cran", "sidebar/contents": "Sommaire", "sidebar/bookmarks": "Marque-pages", "sidebar/bookmarks/add": "Ajouter", "sidebar/bookmarks/remove": "Retirer", "sidebar/bookmarks/clear": "Tout enlever", "sidebar/annotations": "Annotations", "sidebar/annotations/add": "Ajouter", "sidebar/annotations/clear": "Tout enlever", "sidebar/annotations/anchor": "Ancre", "sidebar/annotations/cancel": "Annuler", "sidebar/search": "Rechercher", "sidebar/search/placeholder": "rechercher", "sidebar/settings": "RÃ©glages", "sidebar/settings/language": "Langue", "sidabar/settings/reflowtext": ["RÃ©agencer", "RÃ©agencer les lignes lorsque le panneau latÃ©ral est ouvert"], "sidebar/settings/pagination": ["Pagination", "Ã‰tablir une pagination"] } } } get(e) { return this.values[this.language][e] || "???" } } class C { constructor(e, t) { const s = signals.Signal; this.signals = { sidebarOpener: new s, bookmarked: new s, bookready: new s, renderered: new s, metadata: new s, navigation: new s, layout: new s, selected: new s, unselected: new s, relocated: new s }, this.settings = void 0, this.cfgInit(e, t), this.strings = new x(this), this.toolbar = new g(this), this.sidebar = new w(this), this.content = new y(this), this.book = void 0, this.rendition = void 0, this.displayed = void 0, this.init(), this.keylock = !1, window.addEventListener("beforeunload", this.unload.bind(this), !1), window.addEventListener("hashchange", this.hashChanged.bind(this), !1), window.addEventListener("keydown", this.arrowKeys.bind(this), !1) } init(e, t) { arguments.length > 0 && this.cfgInit(e, t), this.book = new ePub(this.settings.bookPath), this.rendition = this.book.renderTo("viewer", { ignoreClass: "annotator-hl", width: "100%", height: "100%" }); const s = this.settings.previousLocationCfi; this.displayed = s ? this.rendition.display(s) : this.rendition.display(), this.displayed.then((e => { this.signals.renderered.dispatch(e) })), this.book.ready.then(function () { this.settings.pagination && this.generatePagination(), this.signals.bookready.dispatch() }.bind(this)).then(function () { this.content.hideLoader() }.bind(this)), this.book.loaded.metadata.then((e => { this.signals.metadata.dispatch(e) })), this.book.loaded.navigation.then((e => { this.signals.navigation.dispatch(e) })), this.rendition.on("click", (e => { const t = e.view.document.getSelection().getRangeAt(0); t.startOffset === t.endOffset && this.signals.unselected.dispatch() })), this.rendition.on("layout", (e => { this.signals.layout.dispatch(e) })), this.rendition.on("selected", ((e, t) => { this.setLocation(e), this.signals.selected.dispatch(e, t) })), this.rendition.on("relocated", (e => { this.setLocation(e.start.cfi), this.signals.relocated.dispatch(e) })) } defaults(e) { for (let t = 1, s = arguments.length; t < s; t++) { const s = arguments[t]; for (let t in s) void 0 === e[t] && (e[t] = s[t]) } return e } uuid() { let e = (new Date).getTime(); return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => { let s = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" === t ? s : 7 & s | 8).toString(16) })) } isBookmarked(e) { return this.settings.bookmarks.indexOf(e) } isAnnotated(e) { return this.settings.annotations.indexOf(e) } cfgInit(e, t) { this.settings = this.defaults(t || {}, { bookKey: this.getBookKey(e), bookPath: e, restore: !1, history: !0, reload: !1, bookmarks: void 0, annotations: void 0, contained: void 0, styles: void 0, reflowText: !1, pagination: !1, language: void 0 }), this.settings.restore && this.isSaved() && this.applySavedSettings(), void 0 === this.settings.bookmarks && (this.settings.bookmarks = []), void 0 === this.settings.annotations && (this.settings.annotations = []), void 0 === this.settings.styles && (this.settings.styles = { fontSize: "100%" }) } getBookKey(e) { return "epubjs-reader:" + md5(e) } setBookKey(e) { return void 0 === this.settings.bookKey && (this.settings.bookKey = this.getBookKey(e)), this.settings.bookKey } isSaved() { return !!localStorage && null !== localStorage.getItem(this.settings.bookKey) } removeSavedSettings() { return !!this.isSaved() && (localStorage.removeItem(this.settings.bookKey), !0) } applySavedSettings() { if (!localStorage) return !1; let e; try { e = JSON.parse(localStorage.getItem(this.settings.bookKey)) } catch (e) { console.exception(e) } return !!e && (e.styles && (this.settings.styles = this.defaults(this.settings.styles || {}, e.styles)), this.settings = this.defaults(this.settings, e), !0) } saveSettings() { if (this.book) { const e = this.rendition.currentLocation(); e.start && (this.settings.previousLocationCfi = e.start.cfi) } return !!localStorage && (localStorage.setItem(this.settings.bookKey, JSON.stringify(this.settings)), !0) } unload() { this.settings.restore && localStorage && this.saveSettings() } hashChanged() { const e = window.location.hash.slice(1); this.rendition.display(e) } setLocation(e) { const t = "#" + e; this.currentLocationCfi = e, this.settings.history && window.location.hash !== t && window.history.pushState({}, "", t) } generatePagination() { } arrowKeys(e) { if (e.ctrlKey || e.metaKey) { if (void 0 === this.settings.styles) return; void 0 === this.settings.styles.fontSize && (this.settings.styles.fontSize = "100%"); const t = 2; let s = parseInt(this.settings.styles.fontSize.slice(0, -1)); switch (e.key) { case "=": e.preventDefault(), s += t, this.rendition.themes.fontSize(s + "%"); break; case "-": e.preventDefault(), s -= t, this.rendition.themes.fontSize(s + "%"); break; case "0": e.preventDefault(), s = 100, this.rendition.themes.fontSize("100%") }this.settings.styles.fontSize = s + "%" } switch (e.key) { case "ArrowLeft": "rtl" === this.book.package.metadata.direction ? this.rendition.next() : this.rendition.prev(), this.content.prev.addClass("active"), this.keylock = !0, setTimeout((() => { this.keylock = !1, this.content.prev.removeClass("active") }), 100), e.preventDefault(); break; case "ArrowRight": "rtl" === this.book.package.metadata.direction ? this.rendition.prev() : this.rendition.next(), this.content.next.addClass("active"), this.keylock = !0, setTimeout((() => { this.keylock = !1, this.content.next.removeClass("active") }), 100), e.preventDefault() } } } class E { constructor() { this.name = "epubjs-reader", this.version = 1, this.database, this.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB, void 0 === this.indexedDB && alert("The IndexedDB API not available in your browser.") } init(e) { if (void 0 === this.indexedDB) return void e(); const t = this, s = indexedDB.open(this.name, this.version); s.onupgradeneeded = function (e) { const t = e.target.result; !1 === t.objectStoreNames.contains("entries") && t.createObjectStore("entries") }, s.onsuccess = function (s) { t.database = s.target.result, t.database.onerror = function (e) { console.error("IndexedDB", e) }, e() }, s.onerror = function (e) { console.error("IndexedDB", e) } } get(e) { void 0 !== this.database ? this.database.transaction(["entries"], "readwrite").objectStore("entries").get(0).onsuccess = function (t) { e(t.target.result), console.log("storage.get") } : e() } set(e, t) { void 0 !== this.database ? this.database.transaction(["entries"], "readwrite").objectStore("entries").put(e, 0).onsuccess = function () { t(), console.log("storage.set") } : t() } clear() { void 0 !== this.database && (this.database.transaction(["entries"], "readwrite").objectStore("entries").clear().onsuccess = function () { console.log("storage.clear") }) } } window.onload = function () { const e = new E; e.init((function () { e.get((function (e) { window.reader = new C(void 0 !== e ? e :"/contents/book.epub",{restore:!0})}))})),window.storage=e}})();