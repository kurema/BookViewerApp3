<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
    <div class="top">
        <canvas id="mainCanvas" />
    </div>

    <script type="application/json" id="info" style="display:none;">{info.json}</script>

    <script>
        class Page {
            constructor(image) {
                this.Path = image.folder + "/" + image.name;
                this.Data = image;
                this.IsLoading = false;
                this.IsLoaded = false;
                this.Image = null;
            }

            Load() {
                return new Promise((resolve, reject) => {
                    if (this.IsLoaded) {
                        resolve();
                        return;
                    }
                    const img = new Image();
                    img.src = this.Path;
                    this.IsLoading = true;
                    img.onerror = () => {
                        reject();
                    };
                    img.onload = () => {
                        this.Image = img;
                        this.IsLoaded = true;
                        this.IsLoading = false;
                        resolve();
                    }
                });
            }

            get Width() { return this.Image?.width; }
            get Height() { return this.Image?.height; }

            Free() {
                this.Image = null;
                this.IsLoaded = false;
                this.IsLoading = false;
            }
        }

        const pageStaeteEnum = Object.freeze({
            "NotDisplayed": 0,
            "Full": 1,
            "Double": 2,
            "LeftHalf": 3,
            "RightHalf": 4,
        });

        const pageModeEnum = Object.freeze({
            "Simple": 1,
            "AutoDetect": 2,
            "Spread": 3,
            "Half": 4,
        });

        class PageCombinationEntry {
            constructor(page, pageState) {
                this.Page = page;
                this.PageState = pageState;
            }
        }


        class PageCombination {
            constructor(combinations) {
                //Array of PageCombinationEntry
                this.Combinations = combinations;
            }

            get IsEmpty() {
                return Combinations.length === 0;
            }

            get Aspect() {
                let result = 0;
                Combinations.forEach(a => {
                    if (a.Page.Width == null) return;
                    result += a.Page.Width / a.Page.Height;
                });
                return result;
            }

            async Draw(pageDirection, position, zoom) {
                if (this.IsEmpty) return;
                const w = window.innerWidth;
                const h = window.innerHeight;
                //今日は面倒なので明日にする。
            }
        }

        class Book {
            #currentPage;

            constructor(info) {
                this.Images = info.entries.filter(a => IsImage(a.name)).map(a => new Page(a));
                this.#currentPage = this.Images.findIndex(a => a.Path == info.previewFile);
                this.PageMode = pageModeEnum.AutoDetect;
                this.IsPreviewed = false;
                this.PageState = pageStaeteEnum.NotDisplayed;
            }

            get PageCount() { return this.Images.length; }

            get CurrentPage() { return this.Images[this.#currentPage]; }

            async #PageShift(shift) {
                const shifted = this.#currentPage + shift;
                if (shifted >= 0 && shifted < this.Images.length) {
                    this.#currentPage = shifted;
                    await this.Draw();
                }
            }

            async PageShiftRight() {
                await this.#PageShift(-1);
            }

            async PageShiftLeft() {
                await this.#PageShift(+1);
            }

            async Draw() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                canvas.width = w;
                canvas.height = h;

                try {
                    await this.CurrentPage.Load();
                } catch {
                    //読み込み失敗の場合ページを削除する。
                    return;
                }
                ctx.beginPath();
                ctx.fillStyle = "#DDD";
                ctx.fillRect(0, 0, w, h);
                const cw = this.CurrentPage.Width;
                const ch = this.CurrentPage.Height;

                const z = Math.min(w / cw, h / ch);
                const iw = cw * z;
                const ih = ch * z;
                ctx.drawImage(this.CurrentPage.Image, (w - iw) / 2.0 + shiftPoint.x, Math.min(Math.max(0, (h - ih) / 2.0 + shiftPoint.y), h - ih), iw, ih);
            }
        }

        class Vector2 {
            constructor(x, y) {
                this.X = x;
                this.Y = y;
            }
        }

        const topDiv = document.getElementsByClassName("top")[0];
        const canvas = document.getElementById("mainCanvas");
        const ctx = canvas.getContext("2d");

        const info = JSON.parse(document.getElementById("info").innerText);
        const book = new Book(info);

        window.addEventListener('resize', OnResize, false);
        canvas.addEventListener("pointerdown", PointerDown, false)
        canvas.addEventListener("pointermove", PointerMove, false)
        canvas.addEventListener("pointerup", PointerUp, false)

        let startPoint;
        let shiftPoint = { "x": 0, "y": 0 };
        let lastClickTime = null;

        book.Draw();

        function PointerDown(event) {
            if (event.button != 0) return;
            startPoint = { "x": event.screenX, "y": event.screenY };
        }

        async function PointerMove(event) {
            if (startPoint == null) return;
            shiftPoint = { "x": event.screenX - startPoint.x, "y": event.screenY - startPoint.y };
            await book.Draw();
        }

        async function PointerUp(event) {
            if (event.button != 0) return;
            const w = window.innerWidth;
            const x = event.screenX;
            const y = event.screenY;
            const spx = startPoint.x;
            const spy = startPoint.y;
            if (lastClickTime != null && (Date.now() - lastClickTime) < 300) {
                // Double click!
                //    startPoint = null;
                //    return;
            }
            lastClickTime = Date.now();
            if (((x - spx) ** 2 + (y - spy) ** 2) < 100) {
                startPoint = null;
                if (x < w / 4) {
                    await book.PageShiftLeft();
                } else if (x >= w * 3 / 4) {
                    await book.PageShiftRight();
                }
            } else {
                if ((x - spx) * 4 > w) {
                    await book.PageShiftLeft();
                } else if ((x - spx) * 4 < -w) {
                    await book.PageShiftRight();
                }
            }
            startPoint = null;
            shiftPoint = { "x": 0, "y": 0 };
            await book.Draw();
        }

        async function OnResize() {
            startPoint = null;
            shiftPoint = { "x": 0, "y": 0 };
            await book.Draw();
        }

        function IsImage(f) {
            const li = f.lastIndexOf(".");
            const ext = li < 0 ? "" : f.substring(li);

            switch (ext.toUpperCase()) {
                case ".JPEG":
                case ".JPG":
                case ".JFIF":
                case ".PJPEG":
                case ".PJP":
                case ".SVG":
                case ".GIF":
                case ".WEBP":
                case ".PNG":
                case ".APNG":
                case ".AVIF":
                case ".BMP":
                case ".ICO":
                case ".CUR":
                case ".TIF":
                case ".TIFF":
                    return true;
                    break;
                default:
                    return false;
            }
        }
    </script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
        }

        .top {
            display: grid;
            width: 100%;
            height: 100%;
            grid-template: auto 1fr auto;
        }

            .top > #mainCanvas {
                width: 100%;
                height: 100%;
                grid-row: 1/4;
            }
    </style>
</body>
</html>