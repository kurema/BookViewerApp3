/*!
 *                                                                                                                          (℠)
 *  # Bibi Extension: Extractor (on the fly)
 *
 *  * © Satoru Matsushima - https://bibi.epub.link or https://github.com/satorumurmur/bibi
 *  * Open source under the MIT License - https://github.com/satorumurmur/bibi/blob/master/LICENSE
 *
 *  * Depends on:
 *      - Bibi Zip Loader : © Lunascape - https://github.com/lunascape/bibi-zip-loader / Licensed under the MIT License - https://github.com/lunascape/bibi-zip-loader/blob/master/LICENSE
 *
 */!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=24)}({24:function(e,n,t){var r=new(t(25))({url:S.book,worker:document.currentScript.src.replace(/\.js$/,".bibi-zip-loader.worker.js")});Bibi.x({id:"Extractor_on-the-fly",description:"Utilities for Zipped Books. (Method: on-the-fly)",author:"Satoru MATSUSHIMA (@satorumurmur)",version:"1.0.0"})((function(){O.RangeLoader=r}))},25:function(module,exports,__webpack_require__){var factory;window,factory=function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}({"./node_modules/regenerator-runtime/runtime.js":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = (function (exports) {\n "use strict";\n var Op = Object.prototype;\n var hasOwn = Op.hasOwnProperty;\n var undefined; // More compressible than void 0.\n var $Symbol = typeof Symbol === "function" ? Symbol : {};\n var iteratorSymbol = $Symbol.iterator || "@@iterator";\n var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n function wrap(innerFn, outerFn, self, tryLocsList) {\n // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n var generator = Object.create(protoGenerator.prototype);\n var context = new Context(tryLocsList || []);\n // The ._invoke method unifies the implementations of the .next,\n // .throw, and .return methods.\n generator._invoke = makeInvokeMethod(innerFn, self, context);\n return generator;\n }\n exports.wrap = wrap;\n // Try/catch helper to minimize deoptimizations. Returns a completion\n // record like context.tryEntries[i].completion. This interface could\n // have been (and was previously) designed to take a closure to be\n // invoked without arguments, but in all the cases we care about we\n // already have an existing method we want to call, so there\'s no need\n // to create a new function object. We can even get away with assuming\n // the method takes exactly one argument, since that happens to be true\n // in every case, so we don\'t have to touch the arguments object. The\n // only additional allocation required is the completion record, which\n // has a stable shape and so hopefully should be cheap to allocate.\n function tryCatch(fn, obj, arg) {\n try {\n return { type: "normal", arg: fn.call(obj, arg) };\n } catch (err) {\n return { type: "throw", arg: err };\n }\n }\n var GenStateSuspendedStart = "suspendedStart";\n var GenStateSuspendedYield = "suspendedYield";\n var GenStateExecuting = "executing";\n var GenStateCompleted = "completed";\n // Returning this object from the innerFn has the same effect as\n // breaking out of the dispatch switch statement.\n var ContinueSentinel = {};\n // Dummy constructor functions that we use as the .constructor and\n // .constructor.prototype properties for functions that return Generator\n // objects. For full spec compliance, you may wish to configure your\n // minifier not to mangle the names of these two functions.\n function Generator() {}\n function GeneratorFunction() {}\n function GeneratorFunctionPrototype() {}\n // This is a polyfill for %IteratorPrototype% for environments that\n // don\'t natively support it.\n var IteratorPrototype = {};\n IteratorPrototype[iteratorSymbol] = function () {\n return this;\n };\n var getProto = Object.getPrototypeOf;\n var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n if (NativeIteratorPrototype &&\n NativeIteratorPrototype !== Op &&\n hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n // This environment has a native %IteratorPrototype%; use it instead\n // of the polyfill.\n IteratorPrototype = NativeIteratorPrototype;\n }\n var Gp = GeneratorFunctionPrototype.prototype =\n Generator.prototype = Object.create(IteratorPrototype);\n GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n GeneratorFunctionPrototype.constructor = GeneratorFunction;\n GeneratorFunctionPrototype[toStringTagSymbol] =\n GeneratorFunction.displayName = "GeneratorFunction";\n // Helper for defining the .next, .throw, and .return methods of the\n // Iterator interface in terms of a single ._invoke method.\n function defineIteratorMethods(prototype) {\n ["next", "throw", "return"].forEach(function(method) {\n prototype[method] = function(arg) {\n return this._invoke(method, arg);\n };\n });\n }\n exports.isGeneratorFunction = function(genFun) {\n var ctor = typeof genFun === "function" && genFun.constructor;\n return ctor\n ? ctor === GeneratorFunction ||\n // For the native GeneratorFunction constructor, the best we can\n // do is to check its .name property.\n (ctor.displayName || ctor.name) === "GeneratorFunction"\n : false;\n };\n exports.mark = function(genFun) {\n if (Object.setPrototypeOf) {\n Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n } else {\n genFun.__proto__ = GeneratorFunctionPrototype;\n if (!(toStringTagSymbol in genFun)) {\n genFun[toStringTagSymbol] = "GeneratorFunction";\n }\n }\n genFun.prototype = Object.create(Gp);\n return genFun;\n };\n // Within the body of any async function, `await x` is transformed to\n // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n // `hasOwn.call(value, "__await")` to determine if the yielded value is\n // meant to be awaited.\n exports.awrap = function(arg) {\n return { __await: arg };\n };\n function AsyncIterator(generator) {\n function invoke(method, arg, resolve, reject) {\n var record = tryCatch(generator[method], generator, arg);\n if (record.type === "throw") {\n reject(record.arg);\n } else {\n var result = record.arg;\n var value = result.value;\n if (value &&\n typeof value === "object" &&\n hasOwn.call(value, "__await")) {\n return Promise.resolve(value.__await).then(function(value) {\n invoke("next", value, resolve, reject);\n }, function(err) {\n invoke("throw", err, resolve, reject);\n });\n }\n return Promise.resolve(value).then(function(unwrapped) {\n // When a yielded Promise is resolved, its final value becomes\n // the .value of the Promise<{value,done}> result for the\n // current iteration.\n result.value = unwrapped;\n resolve(result);\n }, function(error) {\n // If a rejected Promise was yielded, throw the rejection back\n // into the async generator function so it can be handled there.\n return invoke("throw", error, resolve, reject);\n });\n }\n }\n var previousPromise;\n function enqueue(method, arg) {\n function callInvokeWithMethodAndArg() {\n return new Promise(function(resolve, reject) {\n invoke(method, arg, resolve, reject);\n });\n }\n return previousPromise =\n // If enqueue has been called before, then we want to wait until\n // all previous Promises have been resolved before calling invoke,\n // so that results are always delivered in the correct order. If\n // enqueue has not been called before, then it is important to\n // call invoke immediately, without waiting on a callback to fire,\n // so that the async generator function has the opportunity to do\n // any necessary setup in a predictable way. This predictability\n // is why the Promise constructor synchronously invokes its\n // executor callback, and why async functions synchronously\n // execute code before the first await. Since we implement simple\n // async functions in terms of async generators, it is especially\n // important to get this right, even though it requires care.\n previousPromise ? previousPromise.then(\n callInvokeWithMethodAndArg,\n // Avoid propagating failures to Promises returned by later\n // invocations of the iterator.\n callInvokeWithMethodAndArg\n ) : callInvokeWithMethodAndArg();\n }\n // Define the unified helper method that is used to implement .next,\n // .throw, and .return (see defineIteratorMethods).\n this._invoke = enqueue;\n }\n defineIteratorMethods(AsyncIterator.prototype);\n AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n return this;\n };\n exports.AsyncIterator = AsyncIterator;\n // Note that simple async functions are implemented on top of\n // AsyncIterator objects; they just return a Promise for the value of\n // the final result produced by the iterator.\n exports.async = function(innerFn, outerFn, self, tryLocsList) {\n var iter = new AsyncIterator(\n wrap(innerFn, outerFn, self, tryLocsList)\n );\n return exports.isGeneratorFunction(outerFn)\n ? iter // If outerFn is a generator, return the full iterator.\n : iter.next().then(function(result) {\n return result.done ? result.value : iter.next();\n });\n };\n function makeInvokeMethod(innerFn, self, context) {\n var state = GenStateSuspendedStart;\n return function invoke(method, arg) {\n if (state === GenStateExecuting) {\n throw new Error("Generator is already running");\n }\n if (state === GenStateCompleted) {\n if (method === "throw") {\n throw arg;\n }\n // Be forgiving, per 25.3.3.3.3 of the spec:\n // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n return doneResult();\n }\n context.method = method;\n context.arg = arg;\n while (true) {\n var delegate = context.delegate;\n if (delegate) {\n var delegateResult = maybeInvokeDelegate(delegate, context);\n if (delegateResult) {\n if (delegateResult === ContinueSentinel) continue;\n return delegateResult;\n }\n }\n if (context.method === "next") {\n // Setting context._sent for legacy support of Babel\'s\n // function.sent implementation.\n context.sent = context._sent = context.arg;\n } else if (context.method === "throw") {\n if (state === GenStateSuspendedStart) {\n state = GenStateCompleted;\n throw context.arg;\n }\n context.dispatchException(context.arg);\n } else if (context.method === "return") {\n context.abrupt("return", context.arg);\n }\n state = GenStateExecuting;\n var record = tryCatch(innerFn, self, context);\n if (record.type === "normal") {\n // If an exception is thrown from innerFn, we leave state ===\n // GenStateExecuting and loop back for another invocation.\n state = context.done\n ? GenStateCompleted\n : GenStateSuspendedYield;\n if (record.arg === ContinueSentinel) {\n continue;\n }\n return {\n value: record.arg,\n done: context.done\n };\n } else if (record.type === "throw") {\n state = GenStateCompleted;\n // Dispatch the exception by looping back around to the\n // context.dispatchException(context.arg) call above.\n context.method = "throw";\n context.arg = record.arg;\n }\n }\n };\n }\n // Call delegate.iterator[context.method](context.arg) and handle the\n // result, either by returning a { value, done } result from the\n // delegate iterator, or by modifying context.method and context.arg,\n // setting context.delegate to null, and returning the ContinueSentinel.\n function maybeInvokeDelegate(delegate, context) {\n var method = delegate.iterator[context.method];\n if (method === undefined) {\n // A .throw or .return when the delegate iterator has no .throw\n // method always terminates the yield* loop.\n context.delegate = null;\n if (context.method === "throw") {\n // Note: ["return"] must be used for ES3 parsing compatibility.\n if (delegate.iterator["return"]) {\n // If the delegate iterator has a return method, give it a\n // chance to clean up.\n context.method = "return";\n context.arg = undefined;\n maybeInvokeDelegate(delegate, context);\n if (context.method === "throw") {\n // If maybeInvokeDelegate(context) changed context.method from\n // "return" to "throw", let that override the TypeError below.\n return ContinueSentinel;\n }\n }\n context.method = "throw";\n context.arg = new TypeError(\n "The iterator does not provide a \'throw\' method");\n }\n return ContinueSentinel;\n }\n var record = tryCatch(method, delegate.iterator, context.arg);\n if (record.type === "throw") {\n context.method = "throw";\n context.arg = record.arg;\n context.delegate = null;\n return ContinueSentinel;\n }\n var info = record.arg;\n if (! info) {\n context.method = "throw";\n context.arg = new TypeError("iterator result is not an object");\n context.delegate = null;\n return ContinueSentinel;\n }\n if (info.done) {\n // Assign the result of the finished delegate to the temporary\n // variable specified by delegate.resultName (see delegateYield).\n context[delegate.resultName] = info.value;\n // Resume execution at the desired location (see delegateYield).\n context.next = delegate.nextLoc;\n // If context.method was "throw" but the delegate handled the\n // exception, let the outer generator proceed normally. If\n // context.method was "next", forget context.arg since it has been\n // "consumed" by the delegate iterator. If context.method was\n // "return", allow the original .return call to continue in the\n // outer generator.\n if (context.method !== "return") {\n context.method = "next";\n context.arg = undefined;\n }\n } else {\n // Re-yield the result returned by the delegate method.\n return info;\n }\n // The delegate iterator is finished, so forget it and continue with\n // the outer generator.\n context.delegate = null;\n return ContinueSentinel;\n }\n // Define Generator.prototype.{next,throw,return} in terms of the\n // unified ._invoke helper method.\n defineIteratorMethods(Gp);\n Gp[toStringTagSymbol] = "Generator";\n // A Generator should always return itself as the iterator object when the\n // @@iterator function is called on it. Some browsers\' implementations of the\n // iterator prototype chain incorrectly implement this, causing the Generator\n // object to not be returned from this call. This ensures that doesn\'t happen.\n // See https://github.com/facebook/regenerator/issues/274 for more details.\n Gp[iteratorSymbol] = function() {\n return this;\n };\n Gp.toString = function() {\n return "[object Generator]";\n };\n function pushTryEntry(locs) {\n var entry = { tryLoc: locs[0] };\n if (1 in locs) {\n entry.catchLoc = locs[1];\n }\n if (2 in locs) {\n entry.finallyLoc = locs[2];\n entry.afterLoc = locs[3];\n }\n this.tryEntries.push(entry);\n }\n function resetTryEntry(entry) {\n var record = entry.completion || {};\n record.type = "normal";\n delete record.arg;\n entry.completion = record;\n }\n function Context(tryLocsList) {\n // The root entry object (effectively a try statement without a catch\n // or a finally block) gives us a place to store values thrown from\n // locations where there is no enclosing try statement.\n this.tryEntries = [{ tryLoc: "root" }];\n tryLocsList.forEach(pushTryEntry, this);\n this.reset(true);\n }\n exports.keys = function(object) {\n var keys = [];\n for (var key in object) {\n keys.push(key);\n }\n keys.reverse();\n // Rather than returning an object with a next method, we keep\n // things simple and return the next function itself.\n return function next() {\n while (keys.length) {\n var key = keys.pop();\n if (key in object) {\n next.value = key;\n next.done = false;\n return next;\n }\n }\n // To avoid creating an additional object, we just hang the .value\n // and .done properties off the next function object itself. This\n // also ensures that the minifier will not anonymize the function.\n next.done = true;\n return next;\n };\n };\n function values(iterable) {\n if (iterable) {\n var iteratorMethod = iterable[iteratorSymbol];\n if (iteratorMethod) {\n return iteratorMethod.call(iterable);\n }\n if (typeof iterable.next === "function") {\n return iterable;\n }\n if (!isNaN(iterable.length)) {\n var i = -1, next = function next() {\n while (++i < iterable.length) {\n if (hasOwn.call(iterable, i)) {\n next.value = iterable[i];\n next.done = false;\n return next;\n }\n }\n next.value = undefined;\n next.done = true;\n return next;\n };\n return next.next = next;\n }\n }\n // Return an iterator with no values.\n return { next: doneResult };\n }\n exports.values = values;\n function doneResult() {\n return { value: undefined, done: true };\n }\n Context.prototype = {\n constructor: Context,\n reset: function(skipTempReset) {\n this.prev = 0;\n this.next = 0;\n // Resetting context._sent for legacy support of Babel\'s\n // function.sent implementation.\n this.sent = this._sent = undefined;\n this.done = false;\n this.delegate = null;\n this.method = "next";\n this.arg = undefined;\n this.tryEntries.forEach(resetTryEntry);\n if (!skipTempReset) {\n for (var name in this) {\n // Not sure about the optimal order of these conditions:\n if (name.charAt(0) === "t" &&\n hasOwn.call(this, name) &&\n !isNaN(+name.slice(1))) {\n this[name] = undefined;\n }\n }\n }\n },\n stop: function() {\n this.done = true;\n var rootEntry = this.tryEntries[0];\n var rootRecord = rootEntry.completion;\n if (rootRecord.type === "throw") {\n throw rootRecord.arg;\n }\n return this.rval;\n },\n dispatchException: function(exception) {\n if (this.done) {\n throw exception;\n }\n var context = this;\n function handle(loc, caught) {\n record.type = "throw";\n record.arg = exception;\n context.next = loc;\n if (caught) {\n // If the dispatched exception was caught by a catch block,\n // then let that catch block handle the exception normally.\n context.method = "next";\n context.arg = undefined;\n }\n return !! caught;\n }\n for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n var entry = this.tryEntries[i];\n var record = entry.completion;\n if (entry.tryLoc === "root") {\n // Exception thrown outside of any try block that could handle\n // it, so set the completion value of the entire function to\n // throw the exception.\n return handle("end");\n }\n if (entry.tryLoc <= this.prev) {\n var hasCatch = hasOwn.call(entry, "catchLoc");\n var hasFinally = hasOwn.call(entry, "finallyLoc");\n if (hasCatch && hasFinally) {\n if (this.prev < entry.catchLoc) {\n return handle(entry.catchLoc, true);\n } else if (this.prev < entry.finallyLoc) {\n return handle(entry.finallyLoc);\n }\n } else if (hasCatch) {\n if (this.prev < entry.catchLoc) {\n return handle(entry.catchLoc, true);\n }\n } else if (hasFinally) {\n if (this.prev < entry.finallyLoc) {\n return handle(entry.finallyLoc);\n }\n } else {\n throw new Error("try statement without catch or finally");\n }\n }\n }\n },\n abrupt: function(type, arg) {\n for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n var entry = this.tryEntries[i];\n if (entry.tryLoc <= this.prev &&\n hasOwn.call(entry, "finallyLoc") &&\n this.prev < entry.finallyLoc) {\n var finallyEntry = entry;\n break;\n }\n }\n if (finallyEntry &&\n (type === "break" ||\n type === "continue") &&\n finallyEntry.tryLoc <= arg &&\n arg <= finallyEntry.finallyLoc) {\n // Ignore the finally entry if control is not jumping to a\n // location outside the try/catch block.\n finallyEntry = null;\n }\n var record = finallyEntry ? finallyEntry.completion : {};\n record.type = type;\n record.arg = arg;\n if (finallyEntry) {\n this.method = "next";\n this.next = finallyEntry.finallyLoc;\n return ContinueSentinel;\n }\n return this.complete(record);\n },\n complete: function(record, afterLoc) {\n if (record.type === "throw") {\n throw record.arg;\n }\n if (record.type === "break" ||\n record.type === "continue") {\n this.next = record.arg;\n } else if (record.type === "return") {\n this.rval = this.arg = record.arg;\n this.method = "return";\n this.next = "end";\n } else if (record.type === "normal" && afterLoc) {\n this.next = afterLoc;\n }\n return ContinueSentinel;\n },\n finish: function(finallyLoc) {\n for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n var entry = this.tryEntries[i];\n if (entry.finallyLoc === finallyLoc) {\n this.complete(entry.completion, entry.afterLoc);\n resetTryEntry(entry);\n return ContinueSentinel;\n }\n }\n },\n "catch": function(tryLoc) {\n for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n var entry = this.tryEntries[i];\n if (entry.tryLoc === tryLoc) {\n var record = entry.completion;\n if (record.type === "throw") {\n var thrown = record.arg;\n resetTryEntry(entry);\n }\n return thrown;\n }\n }\n // The context.catch method must only be called with a location\n // argument that corresponds to a known catch block.\n throw new Error("illegal catch attempt");\n },\n delegateYield: function(iterable, resultName, nextLoc) {\n this.delegate = {\n iterator: values(iterable),\n resultName: resultName,\n nextLoc: nextLoc\n };\n if (this.method === "next") {\n // Deliberately forget the last sent value so that we don\'t\n // accidentally pass it on to the delegate.\n this.arg = undefined;\n }\n return ContinueSentinel;\n }\n };\n // Regardless of whether this script is executing as a CommonJS module\n // or not, return the runtime object so that we can declare the variable\n // regeneratorRuntime in the outer scope, which allows this module to be\n // injected easily by `bin/regenerator --include-runtime script.js`.\n return exports;\n}(\n // If this script is executing as a CommonJS module, use module.exports\n // as the regeneratorRuntime namespace. Otherwise create a new empty\n // object. Either way, the resulting object will be used to initialize\n // the regeneratorRuntime variable at the top of this file.\n true ? module.exports : undefined\n));\ntry {\n regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n // This module should not be running in strict mode, so the above\n // assignment should always work unless something is misconfigured. Just\n // in case runtime.js accidentally runs in strict mode, we can escape\n // strict mode using a global Function call. This could conceivably fail\n // if a Content Security Policy forbids using Function, but in that case\n // the proper solution is to fix the accidental strict mode problem. If\n // you\'ve misconfigured your bundler to force strict mode and applied a\n // CSP to forbid Function, and you\'re not willing to fix either of those\n // problems, please detail your unique predicament in a GitHub issue.\n Function("r", "regeneratorRuntime = r")(runtime);\n}\n//LSZL/./node_modules/regenerator-runtime/runtime.js?')},"./src/lszl/lszl.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LSZL; });\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _worker_wrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-wrapper */ "./src/lszl/worker-wrapper.ts");\n/* harmony import */ var _util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/browser */ "./src/util/browser.ts");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar LANE_MULTIPLY = 4;\nvar LSZL =\n/*#__PURE__*/\nfunction () {\n function LSZL(params) {\n var _this = this;\n _classCallCheck(this, LSZL);\n this.params = params;\n _defineProperty(this, "url", void 0);\n _defineProperty(this, "debug", void 0);\n _defineProperty(this, "setupWorkers", void 0);\n _defineProperty(this, "prefetching", void 0);\n _defineProperty(this, "prefetchAll", function () {\n if (_this.prefetching) {\n return _this.prefetching;\n }\n var promise = _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee() {\n var names, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, name;\n return regeneratorRuntime.wrap(function _callee$(_context) {\n while (1) {\n switch (_context.prev = _context.next) {\n case 0:\n _context.next = 2;\n return _this.getEntryNames();\n case 2:\n names = _context.sent;\n _iteratorNormalCompletion = true;\n _didIteratorError = false;\n _iteratorError = undefined;\n _context.prev = 6;\n _iterator = names[Symbol.iterator]();\n case 8:\n if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n _context.next = 15;\n break;\n }\n name = _step.value;\n _context.next = 12;\n return _this.getBuffer(name);\n case 12:\n _iteratorNormalCompletion = true;\n _context.next = 8;\n break;\n case 15:\n _context.next = 21;\n break;\n case 17:\n _context.prev = 17;\n _context.t0 = _context["catch"](6);\n _didIteratorError = true;\n _iteratorError = _context.t0;\n case 21:\n _context.prev = 21;\n _context.prev = 22;\n if (!_iteratorNormalCompletion && _iterator.return != null) {\n _iterator.return();\n }\n case 24:\n _context.prev = 24;\n if (!_didIteratorError) {\n _context.next = 27;\n break;\n }\n throw _iteratorError;\n case 27:\n return _context.finish(24);\n case 28:\n return _context.finish(21);\n case 29:\n case "end":\n return _context.stop();\n }\n }\n }, _callee, null, [[6, 17, 21, 29], [22,, 24, 28]]);\n }))();\n promise.catch(function () {\n return _this.prefetching = undefined;\n });\n return _this.prefetching = promise;\n });\n _defineProperty(this, "abort",\n /*#__PURE__*/\n function () {\n var _ref2 = _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee2(entryName) {\n var workers, index, worker;\n return regeneratorRuntime.wrap(function _callee2$(_context2) {\n while (1) {\n switch (_context2.prev = _context2.next) {\n case 0:\n _context2.next = 2;\n return _this.setupWorkers;\n case 2:\n workers = _context2.sent;\n for (index = 0; index < workers.length; index++) {\n worker = workers[index];\n worker.abort(entryName);\n }\n case 4:\n case "end":\n return _context2.stop();\n }\n }\n }, _callee2);\n }));\n return function (_x) {\n return _ref2.apply(this, arguments);\n };\n }());\n _defineProperty(this, "getEntryNames",\n /*#__PURE__*/\n _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee3() {\n var workers, state;\n return regeneratorRuntime.wrap(function _callee3$(_context3) {\n while (1) {\n switch (_context3.prev = _context3.next) {\n case 0:\n _this.throwIfAbort();\n _context3.next = 3;\n return _this.setupWorkers;\n case 3:\n workers = _context3.sent;\n _context3.next = 6;\n return workers[0].getState();\n case 6:\n state = _context3.sent;\n return _context3.abrupt("return", state.entryNames);\n case 8:\n case "end":\n return _context3.stop();\n }\n }\n }, _callee3);\n })));\n _defineProperty(this, "getBuffer",\n /*#__PURE__*/\n function () {\n var _ref4 = _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee4(entryName) {\n var workers, index, _worker, exists, worker;\n return regeneratorRuntime.wrap(function _callee4$(_context4) {\n while (1) {\n switch (_context4.prev = _context4.next) {\n case 0:\n _this.throwIfAbort();\n _context4.next = 3;\n return _this.setupWorkers;\n case 3:\n workers = _context4.sent;\n index = 0;\n case 5:\n if (!(index < workers.length)) {\n _context4.next = 13;\n break;\n }\n _worker = workers[index];\n exists = _worker.getExistsBuffer(entryName);\n if (!exists) {\n _context4.next = 10;\n break;\n }\n return _context4.abrupt("return", exists);\n case 10:\n index++;\n _context4.next = 5;\n break;\n case 13:\n _context4.next = 15;\n return _this.getMostFreeWorker();\n case 15:\n worker = _context4.sent;\n return _context4.abrupt("return", worker.getBuffer(entryName));\n case 17:\n case "end":\n return _context4.stop();\n }\n }\n }, _callee4);\n }));\n return function (_x2) {\n return _ref4.apply(this, arguments);\n };\n }());\n var url = new URL(params.url, window.location.href).href;\n this.url = url;\n this.throwIfAbort();\n this.setupWorkers = _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee5() {\n var firstWorker, state, workers, multiply, _loop, index;\n return regeneratorRuntime.wrap(function _callee5$(_context5) {\n while (1) {\n switch (_context5.prev = _context5.next) {\n case 0:\n firstWorker = new _worker_wrapper__WEBPACK_IMPORTED_MODULE_1__["default"]({\n url: _this.url,\n worker: _this.params.worker,\n noUseCache: Object(_util_browser__WEBPACK_IMPORTED_MODULE_2__["isIE"])(),\n forceInMemoryCache: _this.params.forceInMemoryCache,\n forceKeepCache: _this.params.forceKeepCache\n });\n _context5.next = 3;\n return firstWorker.getState();\n case 3:\n state = _context5.sent;\n if (!state.fallback) {\n _context5.next = 6;\n break;\n }\n return _context5.abrupt("return", [firstWorker]);\n case 6:\n firstWorker.onFallback = function () {\n return _this.fallback(firstWorker);\n };\n workers = [firstWorker];\n multiply = params.multiply && Math.max(params.multiply, 1) || LANE_MULTIPLY;\n _loop = function _loop(index) {\n var coworker = new _worker_wrapper__WEBPACK_IMPORTED_MODULE_1__["default"]({\n url: _this.url,\n worker: _this.params.worker,\n noUseCache: Object(_util_browser__WEBPACK_IMPORTED_MODULE_2__["isIE"])(),\n forceKeepCache: true\n });\n coworker.onFallback = function () {\n return _this.fallback(coworker);\n };\n workers.push(coworker);\n };\n for (index = 1; index < multiply; index++) {\n _loop(index);\n }\n return _context5.abrupt("return", workers);\n case 12:\n case "end":\n return _context5.stop();\n }\n }\n }, _callee5);\n }))();\n }\n _createClass(LSZL, [{\n key: "getMostFreeWorker",\n value: function () {\n var _getMostFreeWorker = _asyncToGenerator(\n /*#__PURE__*/\n regeneratorRuntime.mark(function _callee6() {\n var workers, minCount, freeWorker, maxCount, index, worker, pendingCount;\n return regeneratorRuntime.wrap(function _callee6$(_context6) {\n while (1) {\n switch (_context6.prev = _context6.next) {\n case 0:\n _context6.next = 2;\n return this.setupWorkers;\n case 2:\n workers = _context6.sent;\n minCount = Number.POSITIVE_INFINITY;\n freeWorker = workers[0];\n maxCount = 0;\n for (index = 0; index < workers.length; index++) {\n worker = workers[index];\n pendingCount = worker.getPendingCount();\n if (minCount > pendingCount) {\n minCount = pendingCount;\n freeWorker = worker;\n }\n maxCount = Math.max(maxCount, pendingCount);\n }\n return _context6.abrupt("return", freeWorker);\n case 8:\n case "end":\n return _context6.stop();\n }\n }\n }, _callee6, this);\n }));\n function getMostFreeWorker() {\n return _getMostFreeWorker.apply(this, arguments);\n }\n return getMostFreeWorker;\n }()\n }, {\n key: "throwIfAbort",\n value: function throwIfAbort() {// NOP\n }\n }, {\n key: "fallback",\n value: function fallback(worker) {\n this.setupWorkers = this.setupWorkers.then(function (workers) {\n return workers.filter(function (one) {\n return one !== worker;\n });\n }).then(function (workers) {\n return workers.forEach(function (one) {\n return one.terminate();\n });\n }).then(function () {\n return [worker];\n });\n }\n }]);\n return LSZL;\n}();\n//LSZL/./src/lszl/lszl.ts?')},"./src/lszl/worker-wrapper.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerWrapper; });\n/* harmony import */ var _resolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resolver */ "./src/resolver.ts");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ "./src/types.ts");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar WorkerWrapper =\n/*#__PURE__*/\nfunction () {\n function WorkerWrapper(params) {\n var _this = this;\n _classCallCheck(this, WorkerWrapper);\n this.params = params;\n _defineProperty(this, "resolvers", void 0);\n _defineProperty(this, "worker", void 0);\n _defineProperty(this, "onFallback", void 0);\n _defineProperty(this, "onmessage", function (ev) {\n var message = ev.data;\n var type = message.type;\n if (type === _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].INIT) {\n _this.resolvers.init.attachMessage(message);\n } else if (type === _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].GET_DATA) {\n var _ref = message,\n _entryName = _ref.meta;\n var resolver = _this.resolvers.getData[_entryName];\n resolver && resolver.attachMessage(message);\n } else if (type === _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].UPDATE_STATE) {\n // const { payload: state } = message as UpdateStateMessage;\n _this.onFallback && _this.onFallback();\n }\n });\n _defineProperty(this, "terminate", function () {\n Object.keys(_this.resolvers.getData).forEach(_this.abort);\n _this.worker.terminate();\n });\n var init = Object(_resolver__WEBPACK_IMPORTED_MODULE_0__["createResolver"])();\n this.resolvers = {\n init: init,\n getData: {}\n };\n this.worker = new Worker(params.worker || \'lszlw.js\');\n this.worker.onmessage = this.onmessage;\n this.worker.postMessage({\n type: _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].INIT,\n payload: params\n });\n }\n _createClass(WorkerWrapper, [{\n key: "getState",\n value: function getState() {\n return this.resolvers.init;\n }\n }, {\n key: "getBuffer",\n value: function getBuffer(entryName) {\n var _this2 = this;\n var exists = this.resolvers.getData[entryName];\n if (exists) {\n return exists;\n }\n var resolver = Object(_resolver__WEBPACK_IMPORTED_MODULE_0__["createResolver"])();\n this.resolvers.getData[entryName] = resolver;\n this.worker.postMessage({\n type: _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].GET_DATA,\n payload: entryName\n });\n resolver.then(function () {\n delete _this2.resolvers.getData[entryName];\n }, function () {\n delete _this2.resolvers.getData[entryName];\n });\n return resolver;\n }\n }, {\n key: "getExistsBuffer",\n value: function getExistsBuffer(entryName) {\n var exists = this.resolvers.getData[entryName];\n if (exists) {\n return exists;\n }\n return undefined;\n }\n }, {\n key: "getPendingCount",\n value: function getPendingCount() {\n return Object.keys(this.resolvers.getData).length;\n }\n }, {\n key: "abort",\n value: function abort(entryName) {\n var exists = this.resolvers.getData[entryName];\n if (exists) {\n this.worker.postMessage({\n type: _types__WEBPACK_IMPORTED_MODULE_1__["MessageType"].ABORT_DATA,\n payload: entryName\n });\n }\n }\n }]);\n return WorkerWrapper;\n}();\n//LSZL/./src/lszl/worker-wrapper.ts?')},"./src/resolver.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResolverStatus", function() { return ResolverStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResolver", function() { return createResolver; });\nvar ResolverStatus;\n(function (ResolverStatus) {\n ResolverStatus[ResolverStatus["PENDING"] = 0] = "PENDING";\n ResolverStatus[ResolverStatus["RESOLVED"] = 1] = "RESOLVED";\n ResolverStatus[ResolverStatus["REJECTED"] = 2] = "REJECTED";\n})(ResolverStatus || (ResolverStatus = {}));\nfunction createResolver() {\n var resolve, reject;\n var resolver = new Promise(function (res, rej) {\n resolve = res;\n reject = rej;\n });\n resolver.status = ResolverStatus.PENDING;\n resolver.attachPromise = function (promise) {\n promise.then(function (result) {\n resolver.status = ResolverStatus.RESOLVED;\n resolve(result);\n }, function (error) {\n resolver.status = ResolverStatus.REJECTED;\n reject(error);\n });\n };\n resolver.attachMessage = function (message) {\n var error = message.error,\n payload = message.payload;\n if (!error) {\n resolver.status = ResolverStatus.RESOLVED;\n resolve(payload);\n } else {\n resolver.status = ResolverStatus.REJECTED;\n reject(payload);\n }\n };\n return resolver;\n}\n//LSZL/./src/resolver.ts?')},"./src/types.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageType", function() { return MessageType; });\nvar MessageType;\n(function (MessageType) {\n MessageType["INIT"] = "INIT";\n MessageType["GET_DATA"] = "GET_DATA";\n MessageType["ABORT_DATA"] = "ABORT_DATA";\n MessageType["UPDATE_STATE"] = "UPDATE_STATE";\n})(MessageType || (MessageType = {}));\n//LSZL/./src/types.ts?')},"./src/util/browser.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIE\", function() { return isIE; });\nfunction isIE() {\n return !!document['uniqueID'];\n}\n//LSZL/./src/util/browser.ts?")},0:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! /home/circleci/bibi-zip-loader/src/lszl/lszl.ts */"./src/lszl/lszl.ts");\n//LSZL/multi_./src/lszl/lszl.ts?')}}).default},module.exports=factory()}});