// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using BookViewerApp.Views.BrowserTools;
//
//    var directoryInfo = DirectoryInfo.FromJson(jsonString);

// kurema did some editing.
// https://app.quicktype.io/?l=csharp
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace BookViewerApp.Views.BrowserTools.DirectoryInfos
{
	using System;
	using System.Collections.Generic;

	using System.Text.Json;
	using System.Text.Json.Serialization;
	using System.Globalization;

	public partial class DirectoryInfo
	{
		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("basePath")]
		public string BasePath { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("currentDirectory")]
		public string CurrentDirectory { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("entries")]
		public List<Entry> Entries { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("pageDirection")]
		public PageDirection? PageDirection { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("previewFile")]
		public string PreviewFile { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("rootName")]
		public string RootName { get; set; }
	}

	public partial class Entry
	{
		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("folder")]
		public string Folder { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("isFolder")]
		public bool? IsFolder { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("name")]
		public string Name { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("size")]
		public long? Size { get; set; }

		[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
		[JsonPropertyName("updated")]
		public DateTimeOffset? Updated { get; set; }
	}

	public enum PageDirection { Down, Left, Right };

	public partial class DirectoryInfo
	{
		public static DirectoryInfo FromJson(string json) => JsonSerializer.Deserialize<DirectoryInfo>(json, BookViewerApp.Views.BrowserTools.CushionInfos.Converter.Settings);
	}

	public static partial class Serialize
	{
		public static string ToJson(this DirectoryInfo self) => JsonSerializer.Serialize(self, BookViewerApp.Views.BrowserTools.CushionInfos.Converter.Settings);
	}

	internal class PageDirectionConverter : JsonConverter<PageDirection>
	{
		public override bool CanConvert(Type t) => t == typeof(PageDirection);

		public override PageDirection Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var value = reader.GetString();
			switch (value)
			{
				case "down":
					return PageDirection.Down;
				case "left":
					return PageDirection.Left;
				case "right":
					return PageDirection.Right;
			}
			throw new Exception("Cannot unmarshal type PageDirection");
		}

		public override void Write(Utf8JsonWriter writer, PageDirection value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case PageDirection.Down:
					JsonSerializer.Serialize(writer, "down", options);
					return;
				case PageDirection.Left:
					JsonSerializer.Serialize(writer, "left", options);
					return;
				case PageDirection.Right:
					JsonSerializer.Serialize(writer, "right", options);
					return;
			}
			throw new Exception("Cannot marshal type PageDirection");
		}

		public static readonly PageDirectionConverter Singleton = new PageDirectionConverter();
	}

	internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
	{
		public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

		private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
		private string? _dateTimeFormat;
		private CultureInfo? _culture;

		public DateTimeStyles DateTimeStyles
		{
			get => _dateTimeStyles;
			set => _dateTimeStyles = value;
		}

		public string? DateTimeFormat
		{
			get => _dateTimeFormat ?? string.Empty;
			set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
		}

		public CultureInfo Culture
		{
			get => _culture ?? CultureInfo.CurrentCulture;
			set => _culture = value;
		}

		public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
		{
			string text;


			if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
				|| (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
			{
				value = value.ToUniversalTime();
			}

			text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

			writer.WriteStringValue(text);
		}

		public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			string? dateText = reader.GetString();

			if (string.IsNullOrEmpty(dateText) == false)
			{
				if (!string.IsNullOrEmpty(_dateTimeFormat))
				{
					return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
				}
				else
				{
					return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
				}
			}
			else
			{
				return default(DateTimeOffset);
			}
		}


		public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
	}
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
